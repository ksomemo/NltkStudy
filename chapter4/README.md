# 4章

## 代入と参照

* 文字列を代入された変数を、新たな変数に代入したあと、その変数を変更しても副作用はない
* 整数についても同様であった
* しかし、リストでは副作用が起こる(変更すると、元の変数に影響する)
* ただし、元の変数自体を文字列や数字に代入し直したときはもとのままであった
* PHPの配列が異端だと思う

### id関数よる識別値

下記はすべて同じ値が表示される

```
id(1)
foo = 1
id(foo)
bar = 1
id(bar)
```

下記もすべて同じ値が表示される

```
id(2)
id(foo + bar)
```

## copy

* copyによるコピーした別物のリストを作成できる
* しかし、リスト内部の参照については変更されていない
* deepcopyでは内部の参照も別物になったコピーが作成される
* ただし、元々同じ参照を持っていたものは同じ参照に変更される

下記はすべて同じ値が表示される
* [:]とcopy.copy
リスト内包表記についてはあとでまとめる

```
import copy
foo = [[]] * 3
```

```
[id(v) for v in foo]
[4419183248, 4419183248, 4419183248]
```

```
id(foo)
4421519552
```

```
bar = foo
id(bar)
4421519552
```

```
bar = foo[:]
id(bar)
4419183608
[id(v) for v in bar]
[4419183248, 4419183248, 4419183248]
```

```
bar = copy.copy(foo)
id(bar)
4425818912
[id(v) for v in bar]
[4419183248, 4419183248, 4419183248]
```

```
bar = copy.deepcopy(foo)
id(bar)
4421547216
[id(v) for v in bar]
[4421547144, 4421547144, 4421547144]
```

### 等価性

* idからの続きのまま比較すると以下のようになる
* 他のプログラミング言語と同じ

foo == bar
True
foo is bar
False

## 条件分岐

下記の標準的なものが存在する

* if
* elif
* else

if式として扱えるかはあとでまとめる

## シーケンス

以下の種類がある
辞書(連想配列？)などはまだ出てきていない

* 文字列
* リスト
* タプル

以下のような共通操作を行える

* 添字でのアクセス
* :を使った範囲取得(スライシング)
* set(重複のないリストへの変換)

```
set("aaabc")
set(['a', 'c', 'b'])
set((1,1,1,2,3))
set([1, 2, 3])
```

* 文字列もシーケンスなのでHaskellの感覚に近い
* タプルへの操作は新しい感覚である

文字型は存在しない？

```
type(("aaabc"))
<type 'str'>
type(('a'))
<type 'str'>
```

### 反復処理

```
for v in seq:
    operation(v)
```

### リスト内包表記

* 反復処理をリストで囲む
* indentせずに処理を行うので見通しが良い(Haskellで慣れただけかも)

### ジェネレータ式

* 反復処理を関数に流し込むときによく使う
* リスト内包表記で流し込むのではなく、要素を流し込む
* リスト全体を確保する必要がなくなるため、メモリ量を抑えることが出来る
* Haskellのfold系や、PHPのジェネレータと同じ
* ジェネレータの作り方は、yieldを使って処理停止および結果を返す
* 結果をその場で返すので、リストに貯めこんで返すコードを書かないことで可読性があがる

### 辞書

連想配列。

```
{"a":1,"b":2,"c":3,"d":4}
```

### シーケンスのカウンター

* enumerateおよびfor文を用いてdictをfor文で回すときのように使う
* 要素の格納されている順番に対応した0から始まる整数を使用できる
* listの場合は、要素を同時に使用できる
* dictの場合は、キーを同時に使用できる。よってdict[key]で要素を参照する

### enumerateの確認およびvar_dump相当のモジュール

* enumerateオブジェクトになっている
* pprint.pprint()でリテラル系を確認できる
* ただし、オブジェクトについては参照しか確認できない
* pip install var_dump でインストールしたモジュールでも確認できない
* dir(obj)を使うとオブジェクトの属性が取得できる(※引数を与えないとdirctoryの中身取得)
* vars()というものもあるが試していない
* \__dict\__という属性を持っていることを要求される事が多い
* list()により表現をリストに変化することが出来る
* dict()により表現を辞書に変化することが出来る
* これらによりenumerateオブジェクトを変更することで確認を行える
* list表現の時はキーと値をタプルとして持つリストであった

### 正規表現

* 使用するには re をimportする
* 正規表現は 'regex' として表現する
* 上記を正規表現オブジェクトとして事前にコンパイルすることで性能が上がる
* 同じ正規表現を繰り返し使うときに使うと良い
* リテラルは存在しない
* '' 内では \ によるエスケープを行える、エスケープ文字自体をマッチさせたいときは重ねる必要がある
* r'' とすることでエスケープ文字自体を重ねる必要がなくなる

### 関数

* 関数定義をした関数名の下に """doc comment""" を書くことが出来る
* function_name.\__doc\__ または help(function_name) でドキュメントコメントの参照が可能である
* return は必須ではない
* rubyのように最後に評価された値は返らず、この場合はNoneを返す(null相当?)
* 再定義してもエラーにならない
* 関数内に存在しない変数を使用するとglobal変数を探してそれを評価する
* それもない場合、NameErrorが発生する
* 引数に関数を渡すことが可能である
* lamda式を作成し、それを引数として渡すことも可能である

### リストのスライス

* [start:end:step]
* 指定位置の取得 (list[index])
* 範囲指定の取得 (list[start:end], endは含まない理由はindexは0始まりのため)
* 取得ステップの指定(list[::step), 2の場合、偶数個目の要素のリストにする)
* 並び順の指定(list[::-1), 逆順ステップとする)

### 引数

* *argsはキーワードなし引数の集まりで、タプルとしてもつ
* **kwargsはキーワードあり引数の集まりで、辞書として持つ
* キーワードあり引数は、キーワードなし引数の間に渡すとエラーになる
* *argsおよび**kwargsという名前でなくとも、アスタリスクがついていれば引数名はなんでもよい
* キーワードあり引数（リストなどのイミュータブルでないもの？）に引数を渡さずに副作用を及ぼすと、次回も引数を渡さず実行すると副作用が残っている

### Debugger

* import pdb
* stepによる関数１行毎の実行
* argsによる引数の確認
* テストコードによる確認で再現不能なときに使いたい

### アルゴリズム

* 再帰が出てきたけど、他の参考書でやったほうがいいと思う
* マージソート実装してみた(NltkStudy/chapter4/src/my_merge_sort.py)
* ヴィラハンカの実装は、V4=S+V3,L+V2を考えれば良いので動的計画法が使える
* Pythonの特性を活かした動的計画法は以下の２つ
* キーワード引数に副作用が働くので、引数をひきまわすコードを書かずに結果を引きませる
* @memoize デコレータによる一度実行した引数に対する結果の保持によるメモ化
* デコレータについては長くなりそうなのでPass。ただ、とてもおもしろそう！

### モジュール

* マージソートを実装したときに、そのソースをインポートするときに学んだ
* chapter4,srcに \__init\__.py というファイルを置く
* ipython上では !シェルのコマンド名 と入力するとシェルのコマンドを実行できる
* !pwd を実行するとNltkStudyディレクトリにいたので \__init\__.pyはここだけに置けば良い
* これにより、そのディレクトリへのモジュール設定が完了する
* srcだけにファイルを置き、chapter4に置かなかった場合はモジュールへのパスが通っていないとみなされる
* \__init\__.py にはモジュール初期化のコードを書くことが出来るらしい
* モジュールの再読み込みは、import でなくreload(module)で行う

### matplotlib

* グラフ描画に使用する
* ~/.matplotlib/matplotlibrc に対してユーザー固有の設定を行える
* プログラムからでも設定できる

以下の設定ファイル記述およびプログラムでの設定をしたときに動かなかった

```
設定ファイル backend:    MacOSX
プログラム   matplotlib.use('Agg')

UserWarning:  This call to matplotlib.use() has no effect
because the backend has already been chosen;
matplotlib.use() must be called *before* pylab, matplotlib.pyplot,
or matplotlib.backends is imported for the first time.
```

* 設定のコメントアウトおよび、プログラム側のコメントアウト解除をするとエラーにはならない
* ただし、このままでは画像は白１色なのでshowでの表示をやめないと画像ファイルとして保存されない

### networkx

* ネットワークグラフ描画用
* pygraphviz(Graphvizに依存 ※Pythonではない)に依存している

```
brew install graphviz
# => version 2.34.0
pip install pygraphviz
pip install networkx
```

### numpy

* 行列計算などの線形代数用
* クラスタリング用のパッケージもある
* 潜在的意味解析(LSA)はSVD(特異値分解)と関係あるらしい(wikiより)
* ほかにもいろいろなパッケージが存在する


