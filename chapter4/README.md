# 4章

## 代入と参照

* 文字列を代入された変数を、新たな変数に代入したあと、その変数を変更しても副作用はない
* 整数についても同様であった
* しかし、リストでは副作用が起こる(変更すると、元の変数に影響する)
* ただし、元の変数自体を文字列や数字に代入し直したときはもとのままであった
* PHPの配列が異端だと思う

### id関数よる識別値

下記はすべて同じ値が表示される

```
id(1)
foo = 1
id(foo)
bar = 1
id(bar)
```

下記もすべて同じ値が表示される

```
id(2)
id(foo + bar)
```

## copy

* copyによるコピーした別物のリストを作成できる
* しかし、リスト内部の参照については変更されていない
* deepcopyでは内部の参照も別物になったコピーが作成される
* ただし、元々同じ参照を持っていたものは同じ参照に変更される

下記はすべて同じ値が表示される
* [:]とcopy.copy
リスト内包表記についてはあとでまとめる

```
import copy
foo = [[]] * 3
```

```
[id(v) for v in foo]
[4419183248, 4419183248, 4419183248]
```

```
id(foo)
4421519552
```

```
bar = foo
id(bar)
4421519552
```

```
bar = foo[:]
id(bar)
4419183608
[id(v) for v in bar]
[4419183248, 4419183248, 4419183248]
```

```
bar = copy.copy(foo)
id(bar)
4425818912
[id(v) for v in bar]
[4419183248, 4419183248, 4419183248]
```

```
bar = copy.deepcopy(foo)
id(bar)
4421547216
[id(v) for v in bar]
[4421547144, 4421547144, 4421547144]
```

### 等価性

* idからの続きのまま比較すると以下のようになる
* 他のプログラミング言語と同じ

foo == bar
True
foo is bar
False

## 条件分岐

下記の標準的なものが存在する

* if
* elif
* else

if式として扱えるかはあとでまとめる

## シーケンス

以下の種類がある
辞書(連想配列？)などはまだ出てきていない

* 文字列
* リスト
* タプル

以下のような共通操作を行える

* 添字でのアクセス
* :を使った範囲取得(スライシング)
* set(重複のないリストへの変換)

```
set("aaabc")
set(['a', 'c', 'b'])
set((1,1,1,2,3))
set([1, 2, 3])
```

* 文字列もシーケンスなのでHaskellの感覚に近い
* タプルへの操作は新しい感覚である

文字型は存在しない？

```
type(("aaabc"))
<type 'str'>
type(('a'))
<type 'str'>
```

### 反復処理

```
for v in seq:
    operation(v)
```

### リスト内包表記

* 反復処理をリストで囲む
* indentせずに処理を行うので見通しが良い(Haskellで慣れただけかも)

### ジェネレータ式

* 反復処理を関数に流し込むときによく使う
* リスト内包表記で流し込むのではなく、要素を流し込む
* リスト全体を確保する必要がなくなるため、メモリ量を抑えることが出来る
* Haskellのfold系や、PHPのジェネレータと同じ
* ジェネレータの作り方が気になる

